"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSuperObject = exports.ResourcePart = exports.HaveResourceAssertion = exports.haveResourceLike = exports.haveResource = exports.ABSENT = void 0;
const assertion_1 = require("../assertion");
const have_resource_matchers_1 = require("./have-resource-matchers");
/**
 * Magic value to signify that a certain key should be absent from the property bag.
 *
 * The property is either not present or set to `undefined.
 *
 * NOTE: `ABSENT` only works with the `haveResource()` and `haveResourceLike()`
 * assertions.
 */
exports.ABSENT = '{{ABSENT}}';
/**
 * An assertion to check whether a resource of a given type and with the given properties exists, disregarding properties
 *
 * @param resourceType the type of the resource that is expected to be present.
 * @param properties   the properties that the resource is expected to have. A function may be provided, in which case
 *                     it will be called with the properties of candidate resources and an ``InspectionFailure``
 *                     instance on which errors should be appended, and should return a truthy value to denote a match.
 * @param comparison   the entity that is being asserted against.
 * @param allowValueExtension if properties is an object, tells whether values must match exactly, or if they are
 *                     allowed to be supersets of the reference values. Meaningless if properties is a function.
 */
function haveResource(resourceType, properties, comparison, allowValueExtension = false) {
    return new HaveResourceAssertion(resourceType, properties, comparison, allowValueExtension);
}
exports.haveResource = haveResource;
/**
 * Sugar for calling ``haveResource`` with ``allowValueExtension`` set to ``true``.
 */
function haveResourceLike(resourceType, properties, comparison) {
    return haveResource(resourceType, properties, comparison, true);
}
exports.haveResourceLike = haveResourceLike;
class HaveResourceAssertion extends assertion_1.JestFriendlyAssertion {
    constructor(resourceType, properties, part, allowValueExtension = false) {
        super();
        this.resourceType = resourceType;
        this.inspected = [];
        this.matcher = isCallable(properties) ? properties :
            properties === undefined ? have_resource_matchers_1.anything() :
                allowValueExtension ? have_resource_matchers_1.deepObjectLike(properties) :
                    have_resource_matchers_1.objectLike(properties);
        this.part = part !== undefined ? part : ResourcePart.Properties;
    }
    assertUsing(inspector) {
        var _a;
        for (const logicalId of Object.keys(inspector.value.Resources || {})) {
            const resource = inspector.value.Resources[logicalId];
            if (resource.Type === this.resourceType) {
                const propsToCheck = this.part === ResourcePart.Properties ? ((_a = resource.Properties) !== null && _a !== void 0 ? _a : {}) : resource;
                // Pass inspection object as 2nd argument, initialize failure with default string,
                // to maintain backwards compatibility with old predicate API.
                const inspection = { resource, failureReason: 'Object did not match predicate' };
                if (have_resource_matchers_1.match(propsToCheck, this.matcher, inspection)) {
                    return true;
                }
                this.inspected.push(inspection);
            }
        }
        return false;
    }
    generateErrorMessage() {
        const lines = [];
        lines.push(`None of ${this.inspected.length} resources matches ${this.description}.`);
        for (const inspected of this.inspected) {
            lines.push(`- ${inspected.failureReason} in:`);
            lines.push(indent(4, JSON.stringify(inspected.resource, null, 2)));
        }
        return lines.join('\n');
    }
    assertOrThrow(inspector) {
        if (!this.assertUsing(inspector)) {
            throw new Error(this.generateErrorMessage());
        }
    }
    get description() {
        // eslint-disable-next-line max-len
        return `resource '${this.resourceType}' with ${JSON.stringify(this.matcher, undefined, 2)}`;
    }
}
exports.HaveResourceAssertion = HaveResourceAssertion;
function indent(n, s) {
    const prefix = ' '.repeat(n);
    return prefix + s.replace(/\n/g, '\n' + prefix);
}
/**
 * What part of the resource to compare
 */
var ResourcePart;
(function (ResourcePart) {
    /**
     * Only compare the resource's properties
     */
    ResourcePart[ResourcePart["Properties"] = 0] = "Properties";
    /**
     * Check the entire CloudFormation config
     *
     * (including UpdateConfig, DependsOn, etc.)
     */
    ResourcePart[ResourcePart["CompleteDefinition"] = 1] = "CompleteDefinition";
})(ResourcePart = exports.ResourcePart || (exports.ResourcePart = {}));
/**
 * Whether a value is a callable
 */
function isCallable(x) {
    return x && {}.toString.call(x) === '[object Function]';
}
/**
 * Return whether `superObj` is a super-object of `obj`.
 *
 * A super-object has the same or more property values, recursing into sub properties if ``allowValueExtension`` is true.
 *
 * At any point in the object, a value may be replaced with a function which will be used to check that particular field.
 * The type of a matcher function is expected to be of type PropertyMatcher.
 *
 * @deprecated - Use `objectLike` or a literal object instead.
 */
function isSuperObject(superObj, pattern, errors = [], allowValueExtension = false) {
    const matcher = allowValueExtension ? have_resource_matchers_1.deepObjectLike(pattern) : have_resource_matchers_1.objectLike(pattern);
    const inspection = { resource: superObj, failureReason: '' };
    const ret = have_resource_matchers_1.match(superObj, matcher, inspection);
    if (!ret) {
        errors.push(inspection.failureReason);
    }
    return ret;
}
exports.isSuperObject = isSuperObject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGF2ZS1yZXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhhdmUtcmVzb3VyY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNENBQWdFO0FBRWhFLHFFQUF1RjtBQUV2Rjs7Ozs7OztHQU9HO0FBQ1UsUUFBQSxNQUFNLEdBQUcsWUFBWSxDQUFDO0FBRW5DOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFnQixZQUFZLENBQzFCLFlBQW9CLEVBQ3BCLFVBQWdCLEVBQ2hCLFVBQXlCLEVBQ3pCLHNCQUErQixLQUFLO0lBQ3BDLE9BQU8sSUFBSSxxQkFBcUIsQ0FBQyxZQUFZLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0FBQzlGLENBQUM7QUFORCxvQ0FNQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsZ0JBQWdCLENBQzlCLFlBQW9CLEVBQ3BCLFVBQWdCLEVBQ2hCLFVBQXlCO0lBQ3pCLE9BQU8sWUFBWSxDQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2xFLENBQUM7QUFMRCw0Q0FLQztBQUlELE1BQWEscUJBQXNCLFNBQVEsaUNBQXFDO0lBSzlFLFlBQ21CLFlBQW9CLEVBQ3JDLFVBQWdCLEVBQ2hCLElBQW1CLEVBQ25CLHNCQUErQixLQUFLO1FBQ3BDLEtBQUssRUFBRSxDQUFDO1FBSlMsaUJBQVksR0FBWixZQUFZLENBQVE7UUFMdEIsY0FBUyxHQUF3QixFQUFFLENBQUM7UUFXbkQsSUFBSSxDQUFDLE9BQU8sR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2xELFVBQVUsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLGlDQUFRLEVBQUUsQ0FBQyxDQUFDO2dCQUNyQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsdUNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO29CQUNoRCxtQ0FBVSxDQUFDLFVB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LG9CQUFZLEtBQVosb0JBQVksUUFZdkI7QUFFRDs7R0FFRztBQUNILFNBQVMsVUFBVSxDQUFDLENBQU07SUFDeEIsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssbUJBQW1CLENBQUM7QUFDMUQsQ0FBQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLGFBQWEsQ0FBQyxRQUFhLEVBQUUsT0FBWSxFQUFFLFNBQW1CLEVBQUUsRUFBRSxzQkFBK0IsS0FBSztJQUNwSCxNQUFNLE9BQU8sR0FBRyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsdUNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsbUNBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUVwRixNQUFNLFVBQVUsR0FBc0IsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUNoRixNQUFNLEdBQUcsR0FBRyw4QkFBSyxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDakQsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0tBQ3ZDO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBVEQsc0NBU0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3NlcnRpb24sIEplc3RGcmllbmRseUFzc2VydGlvbiB9IGZyb20gJy4uL2Fzc2VydGlvbic7XG5pbXBvcnQgeyBTdGFja0luc3BlY3RvciB9IGZyb20gJy4uL2luc3BlY3Rvcic7XG5pbXBvcnQgeyBhbnl0aGluZywgZGVlcE9iamVjdExpa2UsIG1hdGNoLCBvYmplY3RMaWtlIH0gZnJvbSAnLi9oYXZlLXJlc291cmNlLW1hdGNoZXJzJztcblxuLyoqXG4gKiBNYWdpYyB2YWx1ZSB0byBzaWduaWZ5IHRoYXQgYSBjZXJ0YWluIGtleSBzaG91bGQgYmUgYWJzZW50IGZyb20gdGhlIHByb3BlcnR5IGJhZy5cbiAqXG4gKiBUaGUgcHJvcGVydHkgaXMgZWl0aGVyIG5vdCBwcmVzZW50IG9yIHNldCB0byBgdW5kZWZpbmVkLlxuICpcbiAqIE5PVEU6IGBBQlNFTlRgIG9ubHkgd29ya3Mgd2l0aCB0aGUgYGhhdmVSZXNvdXJjZSgpYCBhbmQgYGhhdmVSZXNvdXJjZUxpa2UoKWBcbiAqIGFzc2VydGlvbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBBQlNFTlQgPSAne3tBQlNFTlR9fSc7XG5cbi8qKlxuICogQW4gYXNzZXJ0aW9uIHRvIGNoZWNrIHdoZXRoZXIgYSByZXNvdXJjZSBvZiBhIGdpdmVuIHR5cGUgYW5kIHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXMgZXhpc3RzLCBkaXNyZWdhcmRpbmcgcHJvcGVydGllc1xuICpcbiAqIEBwYXJhbSByZXNvdXJjZVR5cGUgdGhlIHR5cGUgb2YgdGhlIHJlc291cmNlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSBwcm9wZXJ0aWVzICAgdGhlIHByb3BlcnRpZXMgdGhhdCB0aGUgcmVzb3VyY2UgaXMgZXhwZWN0ZWQgdG8gaGF2ZS4gQSBmdW5jdGlvbiBtYXkgYmUgcHJvdmlkZWQsIGluIHdoaWNoIGNhc2VcbiAqICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBjYW5kaWRhdGUgcmVzb3VyY2VzIGFuZCBhbiBgYEluc3BlY3Rpb25GYWlsdXJlYGBcbiAqICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Ugb24gd2hpY2ggZXJyb3JzIHNob3VsZCBiZSBhcHBlbmRlZCwgYW5kIHNob3VsZCByZXR1cm4gYSB0cnV0aHkgdmFsdWUgdG8gZGVub3RlIGEgbWF0Y2guXG4gKiBAcGFyYW0gY29tcGFyaXNvbiAgIHRoZSBlbnRpdHkgdGhhdCBpcyBiZWluZyBhc3NlcnRlZCBhZ2FpbnN0LlxuICogQHBhcmFtIGFsbG93VmFsdWVFeHRlbnNpb24gaWYgcHJvcGVydGllcyBpcyBhbiBvYmplY3QsIHRlbGxzIHdoZXRoZXIgdmFsdWVzIG11c3QgbWF0Y2ggZXhhY3RseSwgb3IgaWYgdGhleSBhcmVcbiAqICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZCB0byBiZSBzdXBlcnNldHMgb2YgdGhlIHJlZmVyZW5jZSB2YWx1ZXMuIE1lYW5pbmdsZXNzIGlmIHByb3BlcnRpZXMgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhdmVSZXNvdXJjZShcbiAgcmVzb3VyY2VUeXBlOiBzdHJpbmcsXG4gIHByb3BlcnRpZXM/OiBhbnksXG4gIGNvbXBhcmlzb24/OiBSZXNvdXJjZVBhcnQsXG4gIGFsbG93VmFsdWVFeHRlbnNpb246IGJvb2xlYW4gPSBmYWxzZSk6IEFzc2VydGlvbjxTdGFja0luc3BlY3Rvcj4ge1xuICByZXR1cm4gbmV3IEhhdmVSZXNvdXJjZUFzc2VydGlvbihyZXNvdXJjZVR5cGUsIHByb3BlcnRpZXMsIGNvbXBhcmlzb24sIGFsbG93VmFsdWVFeHRlbnNpb24pO1xufVxuXG4vKipcbiAqIFN1Z2FyIGZvciBjYWxsaW5nIGBgaGF2ZVJlc291cmNlYGAgd2l0aCBgYGFsbG93VmFsdWVFeHRlbnNpb25gYCBzZXQgdG8gYGB0cnVlYGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXZlUmVzb3VyY2VMaWtlKFxuICByZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgcHJvcGVydGllcz86IGFueSxcbiAgY29tcGFyaXNvbj86IFJlc291cmNlUGFydCkge1xuICByZXR1cm4gaGF2ZVJlc291cmNlKHJlc291cmNlVHlwZSwgcHJvcGVydGllcywgY29tcGFyaXNvbiwgdHJ1ZSk7XG59XG5cbmV4cG9ydCB0eXBlIFByb3BlcnR5TWF0Y2hlciA9IChwcm9wczogYW55LCBpbnNwZWN0aW9uOiBJbnNwZWN0aW9uRmFpbHVyZSkgPT4gYm9vbGVhbjtcblxuZXhwb3J0IGNsYXNzIEhhdmVSZXNvdXJjZUFzc2VydGlvbiBleHRlbmRzIEplc3RGcmllbmRseUFzc2VydGlvbjxTdGFja0luc3BlY3Rvcj4ge1xuICBwcml2YXRlIHJlYWRvbmx5IGluc3BlY3RlZDogSW5zcGVjdGlvbkZhaWx1cmVbXSA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IHBhcnQ6IFJlc291cmNlUGFydDtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXRjaGVyOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgICBwcm9wZXJ0aWVzPzogYW55LFxuICAgIHBhcnQ/OiBSZXNvdXJjZVBhcnQsXG4gICAgYWxsb3dWYWx1ZUV4dGVuc2lvbjogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMubWF0Y2hlciA9IGlzQ2FsbGFibGUocHJvcGVydGllcykgPyBwcm9wZXJ0aWVzIDpcbiAgICAgIHByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IGFueXRoaW5nKCkgOlxuICAgICAgICBhbGxvd1ZhbHVlRXh0ZW5zaW9uID8gZGVlcE9iamVjdExpa2UocHJvcGVydGllcykgOlxuICAgICAgICAgIG9iamVjdExpa2UocHJvcGVydGllcyk7XG4gICAgdGhpcy5wYXJ0ID0gcGFydCAhPT0gdW5kZWZpbmVkID8gcGFydCA6IFJlc291cmNlUGFydC5Qcm9wZXJ0aWVzO1xuICB9XG5cbiAgcHVibGljIGFzc2VydFVzaW5nKGluc3BlY3RvcjogU3RhY2tJbnNwZWN0b3IpOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IGxvZ2ljYWxJZCBvZiBPYmplY3Qua2V5cyhpbnNwZWN0b3IudmFsdWUuUmVzb3VyY2VzIHx8IHt9KSkge1xuICAgICAgY29uc3QgcmVzb3VyY2UgPSBpbnNwZWN0b3IudmFsdWUuUmVzb3VyY2VzW2xvZ2ljYWxJZF07XG4gICAgICBpZiAocmVzb3VyY2UuVHlwZSA9PT0gdGhpcy5yZXNvdXJjZVR5cGUpIHtcbiAgICAgICAgY29uc3QgcHJvcHNUb0NoZWNrID0gdGhpcy5wYXJ0ID09PSBSZXNvdXJjZVBhcnQuUHJvcGVydGllcyA/IChyZXNvdXJjZS5Qcm9wZXJ0aWVzID8/IHt9KSA6IHJlc291cmNlO1xuXG4gICAgICAgIC8vIFBhc3MgaW5zcGVjdGlvbiBvYmplY3QgYXMgMm5kIGFyZ3VtZW50LCBpbml0aWFsaXplIGZhaWx1cmUgd2l0aCBkZWZhdWx0IHN0cmluZyxcbiAgICAgICAgLy8gdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgcHJlZGljYXRlIEFQSS5cbiAgICAgICAgY29uc3QgaW5zcGVjdGlvbiA9IHsgcmVzb3VyY2UsIGZhaWx1cmVSZWFzb246ICdPYmplY3QgZGlkIG5vdCBtYXRjaCBwcmVkaWNhdGUnIH07XG5cbiAgICAgICAgaWYgKG1hdGNoKHByb3BzVG9DaGVjaywgdGhpcy5tYXRjaGVyLCBpbnNwZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnNwZWN0ZWQucHVzaChpbnNwZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZ2VuZXJhdGVFcnJvck1lc3NhZ2UoKSB7XG4gICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gW107XG4gICAgbGluZXMucHVzaChgTm9uZSBvZiAke3RoaXMuaW5zcGVjdGVkLmxlbmd0aH0gcmVzb3VyY2VzIG1hdGNoZXMgJHt0aGlzLmRlc2NyaXB0aW9ufS5gKTtcblxuICAgIGZvciAoY29uc3QgaW5zcGVjdGVkIG9mIHRoaXMuaW5zcGVjdGVkKSB7XG4gICAgICBsaW5lcy5wdXNoKGAtICR7aW5zcGVjdGVkLmZhaWx1cmVSZWFzb259IGluOmApO1xuICAgICAgbGluZXMucHVzaChpbmRlbnQoNCwgSlNPTi5zdHJpbmdpZnkoaW5zcGVjdGVkLnJlc291cmNlLCBudWxsLCAyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3NlcnRPclRocm93KGluc3BlY3RvcjogU3RhY2tJbnNwZWN0b3IpIHtcbiAgICBpZiAoIXRoaXMuYXNzZXJ0VXNpbmcoaW5zcGVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZ2VuZXJhdGVFcnJvck1lc3NhZ2UoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgcmV0dXJuIGByZXNvdXJjZSAnJHt0aGlzLnJlc291cmNlVHlwZX0nIHdpdGggJHtKU09OLnN0cmluZ2lmeSh0aGlzLm1hdGNoZXIsIHVuZGVmaW5lZCwgMil9YDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRlbnQobjogbnVtYmVyLCBzOiBzdHJpbmcpIHtcbiAgY29uc3QgcHJlZml4ID0gJyAnLnJlcGVhdChuKTtcbiAgcmV0dXJuIHByZWZpeCArIHMucmVwbGFjZSgvXFxuL2csICdcXG4nICsgcHJlZml4KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnNwZWN0aW9uRmFpbHVyZSB7XG4gIHJlc291cmNlOiBhbnk7XG4gIGZhaWx1cmVSZWFzb246IHN0cmluZztcbn1cblxuLyoqXG4gKiBXaGF0IHBhcnQgb2YgdGhlIHJlc291cmNlIHRvIGNvbXBhcmVcbiAqL1xuZXhwb3J0IGVudW0gUmVzb3VyY2VQYXJ0IHtcbiAgLyoqXG4gICAqIE9ubHkgY29tcGFyZSB0aGUgcmVzb3VyY2UncyBwcm9wZXJ0aWVzXG4gICAqL1xuICBQcm9wZXJ0aWVzLFxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgZW50aXJlIENsb3VkRm9ybWF0aW9uIGNvbmZpZ1xuICAgKlxuICAgKiAoaW5jbHVkaW5nIFVwZGF0ZUNvbmZpZywgRGVwZW5kc09uLCBldGMuKVxuICAgKi9cbiAgQ29tcGxldGVEZWZpbml0aW9uXG59XG5cbi8qKlxuICogV2hldGhlciBhIHZhbHVlIGlzIGEgY2FsbGFibGVcbiAqL1xuZnVuY3Rpb24gaXNDYWxsYWJsZSh4OiBhbnkpOiB4IGlzICgoLi4uYXJnczogYW55W10pID0+IGFueSkge1xuICByZXR1cm4geCAmJiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGBzdXBlck9iamAgaXMgYSBzdXBlci1vYmplY3Qgb2YgYG9iamAuXG4gKlxuICogQSBzdXBlci1vYmplY3QgaGFzIHRoZSBzYW1lIG9yIG1vcmUgcHJvcGVydHkgdmFsdWVzLCByZWN1cnNpbmcgaW50byBzdWIgcHJvcGVydGllcyBpZiBgYGFsbG93VmFsdWVFeHRlbnNpb25gYCBpcyB0cnVlLlxuICpcbiAqIEF0IGFueSBwb2ludCBpbiB0aGUgb2JqZWN0LCBhIHZhbHVlIG1heSBiZSByZXBsYWNlZCB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgcGFydGljdWxhciBmaWVsZC5cbiAqIFRoZSB0eXBlIG9mIGEgbWF0Y2hlciBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byBiZSBvZiB0eXBlIFByb3BlcnR5TWF0Y2hlci5cbiAqXG4gKiBAZGVwcmVjYXRlZCAtIFVzZSBgb2JqZWN0TGlrZWAgb3IgYSBsaXRlcmFsIG9iamVjdCBpbnN0ZWFkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdXBlck9iamVjdChzdXBlck9iajogYW55LCBwYXR0ZXJuOiBhbnksIGVycm9yczogc3RyaW5nW10gPSBbXSwgYWxsb3dWYWx1ZUV4dGVuc2lvbjogYm9vbGVhbiA9IGZhbHNlKTogYm9vbGVhbiB7XG4gIGNvbnN0IG1hdGNoZXIgPSBhbGxvd1ZhbHVlRXh0ZW5zaW9uID8gZGVlcE9iamVjdExpa2UocGF0dGVybikgOiBvYmplY3RMaWtlKHBhdHRlcm4pO1xuXG4gIGNvbnN0IGluc3BlY3Rpb246IEluc3BlY3Rpb25GYWlsdXJlID0geyByZXNvdXJjZTogc3VwZXJPYmosIGZhaWx1cmVSZWFzb246ICcnIH07XG4gIGNvbnN0IHJldCA9IG1hdGNoKHN1cGVyT2JqLCBtYXRjaGVyLCBpbnNwZWN0aW9uKTtcbiAgaWYgKCFyZXQpIHtcbiAgICBlcnJvcnMucHVzaChpbnNwZWN0aW9uLmZhaWx1cmVSZWFzb24pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXX0=